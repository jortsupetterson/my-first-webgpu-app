<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>My first webGPU app</title>
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; base-uri 'none'; img-src 'self' data:; style-src 'sha256-SXZ+7PyYbrVvBZMsNITWFKF26OomoXnU/bt1XPeei7Q='; script-src 'sha256-oJ5ve6RvvqCRYhGesYSxn1NegTxmV2G9zLdWIdMQbvs='; connect-src 'self';"><link rel="icon" href="/webgpu.svg"><style>html{width:clamp(100dvw,100dvw,100dvw);height:clamp(100dvh,100dvh,100dvh);overflow:hidden}body{margin:0;padding:0;height:clamp(100%,100%,100%);width:clamp(100%,100%,100%);display:flex;justify-content:center;align-items:center;overflow:hidden}</style></head><body><canvas width="256" height="256"></canvas><script type="module">var e=document.querySelector("canvas");try{if(!navigator.gpu)throw new Error("Your browser cant use this system");let r=await navigator.gpu.requestAdapter();if(!r)throw new Error("Could not find a proper adapter");let t=await r.requestDevice();if(!t)throw new Error("No proper hardware found");let n=e.getContext("webgpu"),a=navigator.gpu.getPreferredCanvasFormat();n.configure({format:a,device:t});let i=new Float32Array([-.8,-.8,.8,-.8,.8,.8,-.8,-.8,.8,.8,-.8,.8]),o=t.createBuffer({label:"Cell vertices",size:i.byteLength,usage:GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(o,0,i);let l={arrayStride:8,attributes:[{format:"float32x2",offset:0,shaderLocation:0}]},f=new Float32Array([32,32]),u=t.createBuffer({label:"Grid uniform",size:f.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});t.queue.writeBuffer(u,0,f);let s=t.createShaderModule({label:"Cell shader",code:"@group(0) @binding(0) var<uniform> grid: vec2f;\r\n\r\n@vertex\r\nfn vertexMain(@location(0) pos: vec2f, @builtin(instance_index) instance: u32) -> @builtin(position) vec4f {\r\n    let i = f32(instance);\r\n    let cell = vec2f(i % grid.x, floor(i/grid.y));\r\n    let cellOffset = cell/grid * 2;\r\n    let gridPos = (pos + 1) / grid -1 + cellOffset;\r\n    return vec4f(gridPos, 0, 1);\r\n};\r\n\r\n@fragment\r\nfn fragmentMain() -> @location(0) vec4f {\r\n return vec4f(1,0,0,1);\r\n};"}),d=t.createRenderPipeline({label:"Cell pipeline",layout:"auto",vertex:{module:s,entryPoint:"vertexMain",buffers:[l]},fragment:{module:s,entryPoint:"fragmentMain",targets:[{format:a}]}}),c=t.createBindGroup({label:"Cell rendered bind group",layout:d.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:u}}]}),g=t.createCommandEncoder(),p=g.beginRenderPass({colorAttachments:[{view:n.getCurrentTexture().createView(),loadOp:"clear",storeOp:"store",clearValue:[0,0,.4,1]}]});p.setPipeline(d),p.setVertexBuffer(0,o),p.setBindGroup(0,c),p.draw(i.length/2,1024),p.end(),t.queue.submit([g.finish()])}catch(e){document.body.insertAdjacentHTML("afterend","<span>"+e+"</span>")}</script></body></html>